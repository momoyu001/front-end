# GoGoGo

# [最全的Vue面试题+详解答案](https://juejin.cn/post/6961222829979697165)

# [最全的手写JS面试题](https://juejin.cn/post/6968713283884974088)

# [2020最新：100道有答案的前端面试题（上）](https://juejin.cn/post/6847902225423925255)

# [前端万字面经-基础篇](https://juejin.cn/post/6992767550543265829)

# [前端万字面经-进阶篇](https://juejin.cn/post/6993141036600000548)

## 从输入一个URL地址到浏览器完成渲染的整个过程
- [史上最详细的经典面试题-从输入URL到看到页面发生了什么？](https://juejin.cn/post/6844903832435032072)

- 网络、浏览器原理、前端性能优化

### 简洁版本
- 浏览器输入地址并回车
- 浏览器查找当前URL是否存在缓存，比较缓存是否过期
- DNS解析URL对应的IP
- 根据IP建立TCP连接（三次握手）
- 发送http请求
- 服务器处理请求，浏览器接受HTTP响应
- 浏览器解析并渲染页面
- 关闭TCP连接（四次握手）

### 详细版本
- DNS解析
- 发起TCP连接
- 发起HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束

#### DNS解析
- 是什么？ 网址 和 IP地址 的转换。实际上是一个递归的过程
- 本机域名服务器 -> 根域名服务器 -> COM顶级域名服务器 -> google.com域名服务器
- `.` -> `.com` -> `google.com.` -> `www.google.com`
- 默认情况下，所有的网址的最后一位都是`.`，因为是默认情况，为了方便用户，通常会省略，浏览器在请求DNS的时候会自动加上
- 在有很多服务器来支撑访问的情况下，DNS会返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，机器距离用户的地理位置等，这就是DNS负载均衡
- DNS缓存：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存

#### TCP连接
- 面向连接的、可靠的字节流服务
- TCP报文中的源端口号和目的端口号同IP报文中的源IP与目的IP唯一确定一条TCP连接
- 序号确保了TCP传输的有序性，确保可靠传输的关键部分。序号是该报文段发送的数据组的第一个字节的序号。
- 确认号Ack，指明下一个希望收到的字节序号，表明该序号之前所有的数据，已经准确无误的收到，确认号只有当ACK标志位1的时候才会有效。TCP规定，在建立连接后的所有报文的传输都必须把ACK置1
- 当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1（SYN是用来同步序号的）
- FIN-释放连接，FIN为1，表示此报文的发送方已经发送完毕
- 确认序号Ack = Req + 1；控制位中的确认号ACK

#### 发送HTTP请求
- 发送HTTP请求的过程，就是构建HTTP请求报文，并通过TCP协议发送到服务器指定端口的过程
- 请求报文包括：请求行 + 请求报头 + 请求正文
- GET和POST的区别：
    - GET会产生一个TCP数据包，POST会产生两个TCP数据包
        - GET请求，浏览器会把header和data一起 发送出去
        - POST请求，浏览器会先发送header，服务器响应100 continue，浏览器再发送data
        - 并不是所有浏览器的post请求都会发送两个数据包，Firefox就发送一次
- Connection：keep-alive，用于告诉客户端，本次HTTP请求 结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间
- HTTP属于客户端缓存，常认为浏览器有一个缓存数据库，用来保存一些静态文件。
- 缓存分为：强缓存和协商缓存。强缓存的优先级高于协商缓存。若两种缓存都存在，且强缓存命中，则协商缓存不会再验证标识。
    - 强缓存：缓存数据库中有数据，且没有过期，直接从缓存数据库中取数据，不请求服务器。有数据但是缓存失效，请求服务器，服务器返回数据和缓存规则，将数据和缓存规则存入缓存数据库中
    - 协商缓存：从缓存数据库中获取缓存数据标识，请服务器验证标识是否失效，没有失效则返回304，直接冲缓存中取数据。失效则返回新的数据和缓存规则，将数据和缓存规则存入数据库。
- 缓存的响应头：
    - 强缓存：响应头中的Expires和Cache-Control
        - Expires：服务器返回的数据到期时间。http1.0的。时间的对比可能会有误差，现在更多使用cache-control
        - Cache-Control：
            - Private：客户端可以缓存
            - public：客户端和代理服务器都可以缓存
            - max-age=t：缓存内容将在t秒后失效
            - no-cache：需要使用协商缓存来验证缓存数据
            - no-store：所有内容都不会缓存
    - 协商缓存：
        - Last-Modified：服务器返回的，说明资源的最后修改时间。客户端在请求时会带上`if-Modified-Since`，值为资源的最后修改时间，服务器收到后对比时间，判断资源有没有过期
        - Etag：服务器响应头中，告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）。客户端再次请求时会带上`if-None-Match`，服务器匹配这个唯一 标识，不同则说明该资源被改动过
- 不同的刷新页面的方式
    - 浏览器地址栏中写入URL，回车：发现有缓存，就不继续请求了，直接从缓存中取
    - F5，取服务器看看资源是否 过期，请求会带上if-modified-since
    - Ctrl+F5：吧缓存的文件删了，从服务器请求完整的资源

#### 浏览器渲染页面
- 回流：
    - 一些常用且会导致回流的属性和方法
        - clientWidth、clientHeight、clientTop、clientLeft。。。

## webpack的loader和plugin
- loader - 用于处理模块源码的转换，描述了webpack如何处理非JavaScript模块。从不同的语言转换为JavaScript语言（css-loader、style-loader）
- plugin - 用于解决loader无法实现的其他事，直接作用于webpack，扩大webpack的功能。

- [前端进阶高薪必看-webpack篇](https://juejin.cn/post/6844904150988226574)

## JS的事件流
### 冒泡阶段
从确定的目标到不确定的目标
### 目标阶段
触发事件的真正元素
### 捕获阶段
从不确定的目标到确定的目标
### addEventListener
- addEventListener('', callback, false);
- 第三个参数：默认值为false，表示此时是冒泡阶段；为true则为捕获阶段 -- isCapture
- target --- 触发事件的元素
- currentTarget --- 事件绑定的元素

### 事件委托
- 不给每个子节点设置事件监听器，而是在父节点上设置，然后利用事件冒泡原理设置每个子节点
- 优点：
    - 动态绑定事件：因为事件绑定在父元素上面，新添加的元素也可以触发事件
    - 减少内存消耗和dom操作。
        - 每个事件处理函数都是一个对象，多一个事件处理函数，内存中就被多用了一部分空间。
        - 添加到页面上的事件处理程序数量直接关系到页面的整体运行性能，因为需要不断的操作dom，那么引起回流和重绘的可能也就越多，页面交互的时间也会变得越长。

## 渲染层合成
在DOM树中的每一个节点都会对应一个渲染对象，当他们的渲染对象处于同一个坐标空间（Z轴空间）时。就会形成一个渲染层。渲染层将保证页面元素以正确的的顺序进行堆叠，这时候就会出现层合成，从而正确的处理透明元素和重叠元素的显示。

浏览器创建新的渲染层：
- 根元素
- 有明确的定位元素（relative、fixed、sticky、absolute）
- CSS filter属性
- CSS mask属性
- CSS transform不为none
- overflow不为visible


## call apply bind
### 共同点
- 改变this的指向
- 三者的第一个参数，都是this要指向的对象，没有这个参数则设置为undefined或者null，则默认指向全局window
- 
### 不同点
- call：出第一个参数外，后续的参数是一个接一个的，不是数组。是一次性传入参数。
- apply：除第一个参数外，后续的参数是参数列表。是一次性传入参数。
- bind：出第一个参数外，后续的参数是一个接一个的，不是数组，参数可以分多次传入。

- call、apply函数时立即执行的；bind函数不是立即执行，会返回一个新的函数。如果这个返回的函数作为构造函数创建一个新的对象，那么此时this不会指向传给bind的 第一个参数，而是指向用new创建的实例
    ```
// let没有变量提升，用let声明的变量，不会默认成为window的属性
        let name = '我是全局的name';

        window.name = '我是window的name';  
        
        let age = 120;

        // var 声明变量有变量提升，默认会成为window的属性。
        var number = 20;

        let originObj = {
            name: '改变后的的对象name'
        }

        function testFunc() {
            // 
            console.log('我输出啦。。。。', this.name, ...arguments);
            console.log(this)

            // 这个局部 var声明的变量不会成为window的属性
            var testVar = 33333;
        }

        testFunc(1);

        // 改变this的指向
        testFunc.call(originObj, 2, 3);

        testFunc.apply(originObj, [4, 5]);

        testFunc.bind(originObj, 6, 7)();

        let latestObj = new testFunc(originObj, 8, 9);
    ```
- tips：this的指向
    - ES5中：this永远指向调用它的那个对象。var声明的变量默认自动成为window的属性。let声明的变量则不会。
    - ES5中，前面没有调用的对象，那么就是全局对象window。严格模式下全局对象window为undefined


## 闭包的运用 - 栗子

**闭包的定义：当一个函数被创建并传递或者从另一个函数返回时，它会携带一个背包，背包中是函数声明时作用域内的所有变量**    *当一个函数被创建并传递或者从另一个函数返回时，他会携带函数声明时作用域内的所有的变量*

- 防抖：持续触发事件处理函数，只有当一段时间没有触发时，没回执行事件处理函数
    ```
        // 防抖：一定事件间隔之后，才会执行这个事件处理函数
        function debounce(fn, time) {
            let timer = null;

            // 使用到闭包来处理
            return function() {
                // 把原来的定时器清掉，再重新开始一个定时器，又触发的话，又继续清掉，重新设置。。。
                // 直到没有再触发，执行最后设置的哪个定时器
                clearTimeout(timer);

                timer = setTimeout(() => {
                    fn();
                }, time);
            }
        }
    ```
- 节流：一定时间内只会执行一次事件处理函数
    ```
        // 节流：一段时间内只触发一次执行函数
        function throltle(fn, time) {
            let timer = null;

            return (val) => {
                // timer不为空的时候，就return
                if (timer) {
                    return;
                }

                timer = setTimeout(() => {
                    fn(val);
                    clearTimeout(timer);
                    timer = null;
                }, time);
            }
        }
    ```
- 使用闭包模拟块级作用域
    ```
    function outputNumbers(count) {
        (function() {
            for (var i = 0; i < count; i++) {
                alert(i);
            }
        })();
        alert(i) // 会报错
    ```
- 闭包可以用于在对象中创建私有变量。


## CSS优先级
- ！important 优先级最高
- 内联样式 style
- ID选择器
- 类、伪类、属性选择器: .foo    :first-child   div[class="foo"]
- 标签、伪元素选择器：div    ::first-line
- 通配符、子类选择器、兄弟选择器： *   >    +
- 继承的样式没有权重

## 事件循环
JS有同步任务和异步任务的概念，同步任务在主线程执行，会形成一个执行栈。事件触发线程管理着一个任务队列，当异步任务有了执行，就会在任务队列中放入一个事件回调。一旦执行栈中的任务执行完，就会读取任务队列，将可执行的异步任务添加到执行栈中，开始执行。

JS的异步任务还可以细分为微任务、、宏任务。

执行栈 -- 任务队列 -- 执行栈  循环往复 ----> 事件循环

JS还有宏任务和微任务之分。

常见的宏任务：
- script代码块
- setTimeout
- setInterval
- setImmidiate

常见的微任务
- primise.then
- catch
- finally
- process.nextTick

```js
 // JS事件循环
            console.log('1'); // 1

            setTimeout(function () {
                // 宏-1
                console.log('2');
                process.nextTick(function () {
                    // 微-1
                    console.log('3');
                });

                new Promise(function (resolve) {
                    // 宏-2
                    console.log('4');
                    resolve();
                }).then(function () {
                    // 微-2
                    console.log('5');
                });
            });

            process.nextTick(function () {
                // 微-3
                console.log('6');
            });

            new Promise(function (resolve) {
                // 宏-3
                console.log('7');
                resolve();
            }).then(function () {
                // 微-4
                console.log('8');
            });

            setTimeout(function () {
                // 宏-4
                console.log('9');
                process.nextTick(function () {
                    // 微-5
                    console.log('10');
                });

                new Promise(function (resolve) {
                    // 宏-5
                    console.log('11');
                    resolve();
                }).then(function () {
                    // 微-6
                    console.log('12');
                });
            });

            /**
             * 
                    宏任务：宏-1 宏-4
                    微任务：微-3 微-4

                    1、第一轮事件循环之后，执行微任务 微- 3，微- 4
                    2、执行宏 - 1
                    宏任务：宏-4
                    微任务：微-1  微-2
                    3、执行微任务 1 2
                    4、执行宏-4
                    宏任务：
                    微任务：微-5  微-6
                    5、执行微任务

                    输出   1    7（宏-3）   6   8   2   4   3   5   9   11  10 12
             * 
             * **/
```

## http状态码
### 1xx 继续请求

post 请求。会发送两个数据包，header和data是分开发送的，header先发送，状态码为100，继续请求，data发送完，状态码才是200
### 2XX 请求成功
- 204 无内容，服务器成功处理了请求，但是没有内容返回
### 3XX 重定向
- 301 请求的网页已移动到新的位置，服务器会自动将请求转到新的位置 --- 永久移动
- 302 服务器从不同的位置的网页响应请求，但是请求者应该还是使用原来的位置请求 ---- 临时移动
- 304 未修改，不会返回内容，客户端直接从缓存中取
### 4XX 客户端发生错误
- 400 错误请求，服务器不理解请求的语法，一般为参数错误
- 401 未授权，需要验证身份
- 403 禁止访问
- 404 服务器找不到请求的网页
### 5XX服务端发生错误

## http2.0做了哪些改进？3.0呢？

http是应用层协议，建立在传输层上面，传输层协议有tcp、udp，2.0和1.0都是基于TCP的，因此都会有TCP带来的硬伤以及局限性。3.0是建立在UDP的基础上的，所以3.0和2.0有着本质的不同。

[Http2.0的一些思考以及Http3.0的优势](https://blog.csdn.net/m0_60360320/article/details/119812431)

### 2.0的特性
- 二进制分帧传输
- 多路复用
- 头部压缩
- 服务器推送

### 3.0的特性
- 连接迁移
- 无对头阻塞
- 自定义的拥塞控制
- 前向安全和前向纠错


## 作用域
执行一段JavaScript代码必不可少的：JS引擎 + 编译器。

### 编译
- 词法分析
- 语法分析

## Promise的实现
根据Promise/A+规范来实现。

### 基础功能的实现
- 三种状态
- 一个构造函数
- 一个then方法

### then方法的实现
- resovled状态时的实现
- rejected状态时的实现
- pending状态时的实现

### 支持异步的实现
- 各需一个数组来存放成功的回调和失败的回调
- then方法中，当状态为pending时，放入各自的回调数组中
- 在resolve方法和rejected方法中，去调用各个回调函数实现异步的处理

### 链式调用的实现

#### then的需求
- then方法要返回一个**Promise对象**
- 如果then返回的是一个普通值（如Number、String），就用此值包装成一个新的Promise对象返回
- 如果then方法中，没有return语句，就返回一个用undefined包装的Promise对象
- 如果then方法中出现异常，则调用失败状态下的方法跳转到下一个then的onRjected
- 如果then没有传入任何回调，则继续向下传递（值穿透）
- 如果then中返回了一个Promise对象，那就以这个对象为准，返回它的结果

#### then的实现
- then方法没有传入回调的时候，则继续向下执行。但是每个then都要返回一个新的Promise对象
```
Promise.prototype.then = function (onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (value) => value

    onRejected = typeof onRejected === 'function' ? onRejected : (err) => err

    // 每个then都返回一个Promise对象
    let promise2 = new Promise((resolve, reject) => {
        if (this.state === 'pending') {
            // 直接将回调push
            // this.onResolvedCallbacks.push(onFulfilled)
            // this.onRejectedCallbacks.push(onRejected)

            // 回调外面再套一个回调
            this.onResolvedCallbacks.push(() => {
                try {
                    let x = onFulfilled(this.value);
                    resolve(x);
                } catch (err) {
                    reject(err);
                }
            })

            this.onRejectCallbacks.push(() => {
                try {
                    let x = onRejected(this.reason);
                    resolve(x);
                } catch (err) {
                    reject(err);
                }
            })
        }

        if (this.state === 'resolved') {
            try {
                // 拿到返回值resolve出去
                let x = onFulfilled(this.value);
                resolve(x);
            } catch (err) {
                // catch 捕获异常rejecte抛出
                reject(err);
            }
        }

        if (this.state === 'rejected') {
            try {
                let x = onRejected(this.reason);
                resolve(x);
            } catch (err) {
                reject(err);
            }
        }
    })

    return promise2;
}
```

```
    // 测试 then 方法没有传入回调的场景
    let p1 = new Promise((resolve, reject) => {
        // 状态该为rejected
        reject('p1 --- 1000')
    }).then((data) => {
        // 这个then里面，没有rejected状态的回调，then方法里面会生成这个回调，再返回一个新的promise对象，可以一直链式调用下去
        console.log(data);
    }).then((data) => {
        console.log(data);
    })
```

- then 根据上一个then方法的返回值来生成新的Promise对象 --- 逻辑复杂
    ```
        /**
         * 解析then返回值与新的promise对象
         * @param {Object} 新的Promise对象，就是我们创建的promise2实例
         * @param {*} 上一个then的返回值
         * @param {Function} resolve promise2处理器函数的resolve
         * @param {Function} reject promise2处理器函数的reject
         * **/
        function resolvePromise(promise2, x, resolve, reject) {
            // 1、为避免循环引用，当then的返回值与新生成的Promise对象为同一个（引用地址相同），则抛出TypeError错误。否则程序会死掉
            if (promise2 === x) {
                reject(new TypeError('请避免Promise循环引用'));
            }

            // 2、判断x的类型，分情况处理
            
        }
    ```
    - 为避免循环引用，当then的返回值与新生成的Promise对象为同一个（即引用地址相同），则抛出TypeError的错误。如果返回了自己的 Promise对象，状态永远为等待态，再也无法成为 resolved或是rejected，程序就死掉了。
    ```
        let promise2 = new Promise((resolve, reject) => {
            return promise2;
        })
    ```
    - 判断x的类型，分情况处理
        - 当x为一个Promise对象时，执行这个对象，成功即成功，失败即失败
        - 若x是一个对象或者函数，再进一步处理它
        - 否则就是一个普通值

        - 考虑：当promise对象转为成功态或者失败的时候，传入的还是一个promise对象，此时应该继续执行，知道最后的promise执行完。采用递归的方式解决：递归resolvePromise方法，知道将promise解析为一个普通值。
            ```
                // 传入的还是promise对象的栗子
                Promise.resolve(1).then((resolve) => {
                    return new Promise((resolve, reject) => {
                        resolve(
                            // 这个resolve传入的还是一个promise对象，此时应当继续执行这个传入的promise，知道解析为一个普通值。
                            new Promise((resolve, reject) => {
                                reslove(2)
                            })
                        )
                    })
                })

                resolvePromise(promise2, y, resolve, reject);
            ```
        - promise/A+规范定义：如果resolvePromise和rejectPromise都被 调用，或者多次调用同一个参数，第一个调用优先，任何进一步的调用都将被忽略，设定一个called来防止多次调用
    - Promise 中处理器函数时同步执行的，then方法时异步的还是一个微任务。我们用`queueMicrotask`来实现一个微任务。
        ```
        queueMicrotask(() => {
            try {
                let x = onFulfiiled(calue);
                resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
                reject(e);
            }
        })
        ```



#### catch的实现
直接执行then方法，onFulfilled为none，传入onRejected

```
Promise.prototype.catch = function (onRejected) {
    return this.then(null, onRejected);
}
```

#### resolve的实现
直接抛出一个成功状态的promise。

```
Promise.resolve = function (val) {
    return new Promise((resolve, reject) => {
        resolve(val);
    })
}
```

#### reject的实现
直接抛出一个拒绝状态的promise。

```
Promise.reject = function (val) {
    return new Promise((resolve, reject) => {
        reject(val);
    })
}
```

#### race方法的实现
```
Promise.race = function (promises) {
    return new Promise((resolve, reject) => {
        // 遍历执行promises
        for (let i = 0; i < promises.length; i++) {
            // then 只要接收到状态改变，就直接抛出
            promises[i].then(resolve, reject)
        }
    })
}
```

#### all方法的实现

获取到所有的promise，都执行then，把结果放到数组，一起返回

```
Promise.all = function (arr) {
    let aResult = [];
    return new Promise(function(resolve, reject) {
        let i = 0;
        // 开始逐次执行数组中的函数（重要）
        next();

        function next() {
            arr[i].then(function(res) {
                // 存储每次得到的结果
                aResult.push(res);

                i++;

                if (i >= arr.length) {
                    // 如果函数数组中的函数都执行完，变resolve
                    resolve(aResult);
                } else {
                    next();
                }
            })
        }
    })
}
```

#### 总结
- then方法返回的是一个全新的promise对象
- then方法是一个微任务这种说法是不准确的，应该说then方法的回调函数，会被作为微任务执行。
- then方法并不是在上一个Promise对象resolve之后才执行的，它在一开始就执行并返回了一个新的promise对象，在返回的新的promise对象中会根据上一个promise的状态来做出判断。
    - 上一个promise状态在成功态的时候，会直接then方法回调作为微任务入队列
    - 上一个promise状态在失败态的时候，会直接then方法回调作为微任务入队列
    - 上一个promise状态在等待态的时候，它的内部会把then方法的回调使用微任务方法包裹缓存到新的 promise实例数组中，并没有直接入队。当上一个promise从等待态变为成功态的时候，会调用其自身返回的的新的promise的resolve方法，从而调用新的promise的实例数组中的方法，这时微任务方法包裹的回调函数就会执行，即入栈。
- 上一个promise中return一个Promise和直接return一个值或者不写值的处理方式是不一样的。
    - 上一个promise中什么都不return，即回调的返回值为 undefined，和直接return一个值一样，都会在promise状态为成功态时调用其返回时内部 创建的新的Promise的resolve方法并将值传出
    - 上一个promise对象中return一个promise对象的话，会会上一个promise对象状态为成功态时，调用其then方法执行，拿到值resolve或reject出去。（由于return promise时会在内部执行一个 then方法，所以这里多执行了一个微任务，但是这个微任务其实什么都没有做，只是为了取我们自己return的Promise的值）
    - 实际：现在浏览器中的执行结果是 --- then方法中，如果返回的是一个promise对象，内部会产生两个微任务，两个无输出的微任务

## position的值有哪些
- static
- absolute：给元素设置绝对的定位。
    - 如果存在有祖先元素设置了relative定位或absolute，那么此时元素的定位对象为这个有定位的元素
    - 如果没有祖先元素设置了relative或者absolute定位，那么元素会相对于body进行定位
- relative：给元素设置相对于原本位置的定位，元素不脱离文档流，因此元素原位置还是会被保留，其他元素的位置不会收到影响。
- sticky：在屏幕范围内（viewport）时，该元素的位置并不收到定位影响（设置的top、left是无效的），当该元素的 位置将要移除偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果
- fixed：总是相对于body进行定位

## 垂直水平 居中的 实现方式 

### 定宽高

#### 绝对定位 + margin负值
```
position: absolute;
top: 50%;
left: 50%;
margin-left: 自身宽度的一半;
margin-top: 自身高度的一半;
```

#### 绝对定位 + transform
```
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
```

#### 绝对定位 + left/right/top/bottom + margin
```
position: absolute;
display: inline;
top: 0;
right: 0;
bottom: 0;
left: 0;
margin: auto;
```

#### flex布局

#### grid
```
// parent
display: grid;

// children
margin: auto;
```

#### table
```
// parent
display: table-cell;
text-align: center;
vertical-align: middle;

// children
display: inline-block
或者
margin: auto;
```

### 不定高宽

#### 绝对定位 + transform
```
position: absolute;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
```

#### tabel-cell
```
// parent
display: table-cell;
text-align: center;
verticle-align: middle;

// children
display: inline-block;
```

#### flex布局

#### flex变异布局
```
// parent
display: flex;

// children
margin: auto;
```

#### grid + flex
```
// parent
display: grid;

// children
align-self: center;
justify-self: center;
```

#### grid + margin

#### writing-mode
writing-mode属性定义了文本在水平或者垂直方向上如何排布。

## vue组件通信的方法
- props和$emit父组件向子组件传递数据是通过props进行的，子组件传递数据给父组件是通过$emit触发事件进行的
- $parent $children获取当前组件的父组件和子组件
- $attrs  $listeners
- 父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量（写组件库时很常用）
- $ref 获取组件实例
- eventBus 兄弟组件数据传递 ，这种情况下可以使用事件总线的方式
- vuex状态管理

## vue的响应式原理

**数据劫持 + 观察者模式**

对象内部通过defineReactive方法，使用Object.defineProperty方法将属性劫持（只会劫持已经存在的属性），数组则是通过重写数组的方法来实现。

当页面使用对应属性的时候，每个属性都用有自己的dep属性，存放他所依赖的watcher（依赖收集），当属性变化后会通知自己对应的watcher去更新（派发更新）。

[vue响应式原理详解](https://juejin.cn/post/6935344605424517128)

```
        class Observe {
            constructor(value) {
                this.walk(value);
            }

            walk(data) {
                // 对象上的所有属性依次进行观测
                let keys = Object.keys(data);

                for (let i = 0; i < keys.length; i++) {
                    let key = keys[i];
                    let value = data[key];
                    defineReactive(data, key, value);
                }
            }
        }

        // Object.defineProperty数据劫持核心，兼容性在IE9以上
        function defineReactive(data, key, value) {
            // 递归的关键
            observe(value);

            // 如果value还是一个对象，会继续走一遍defineReactive，层层遍历一直到value不是对象才停

            Object.defineProperty(data, key, {
                get() {
                    console.log('获取值。。。');

                    // 这里有处理依赖收集的过程。。。。。省略了。。。

                    return value;
                },

                set(newValue) {
                    if (newValue === value) return;
                    console.log('设置值');

                    // 需要做派发更新过程。。。。。省略了。。。

                    value = newValue;
                }
            })
        }

        export function observe(value) {
            // 如果传过来的是对象或者数组 进行属性劫持
            if (Object.prototype.toString.call(value) === '[object object]' || Array.isArray(value)) {
                return new Observe(value);
            }
        }
```

### 观察者模式
当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖他的对象都会收到通知。观察者和目标之间有很强的依赖关系。

目标对象：
    维护观察者列表
    定义添加观察者的方法
    当自己发生变化之后，通过调用自己的notify方法通知每个观察者执行update方法。

观察者：
    要实现自己的update方法

代码实现：
```js
    // 观察者模式
    // 目标对象：要实现添加观察者的方法，通知观察者的方法
    function Subscribe() {
        this.oberserList = [];
    }

    Subscribe.prototype.addObserver = function (observer) {
        this.oberserList.push(observer);
        console.log('添加了。。。');
    }

    // 这里不能使用箭头函数，箭头函数的this来自父级作用域，这里用箭头函数的话，指向的this就是window
    Subscribe.prototype.notify = function () {
        this.oberserList.forEach(obs => obs.update());
    }

    function Observer(name) {
        this.name = name
    }

    Observer.prototype.update = function() {
        console.log(this.name, '更新啦')
    }

    let Sub = new Subscribe();
    let ob1 = new Observer('1号');
    let ob2 = new Observer('2号');
    let ob3 = new Observer('3号');

    Sub.addObserver(ob1);
    Sub.addObserver(ob2);
    Sub.addObserver(ob3);

    setTimeout(function() {
        Sub.notify()
    }, 2000)
```

```js
    class Subscribe {
        constructor() {
            this.observerList = [];
        }

        addObserver(observer) {
            console.log('添加了')
            this.observerList.push(observer);
        }

        notify() {
            this.observerList.forEach(observer => observer.update());
        }
    }

    class Observer {
        constructor(name) {
            this.name = name;
        }

        update() {
            console.log(`${this.name}更新了。。。`);
        }
    }

    let Sub = new Subscribe();

    let ob1 = new Observer('111');
    let ob2 = new Observer('222');
    let ob3 = new Observer('333');
    let ob4 = new Observer('444');

    Sub.addObserver(ob1);
    Sub.addObserver(ob2);
    Sub.addObserver(ob3);
    Sub.addObserver(ob4);

    setTimeout(() => {
        Sub.notify();
    }, 2000);
```

### 发布/订阅模式
基于一个事件（主题）通道，希望接收通知的对象，通过自定义事件订阅主题，被激活事件的对象通过发布主题的方式通知各个订阅该主题的对象。发布者和订阅者之间是耦合度低的。

发布者：添加调度中心的方法，推送消息的方法 -- 执行调度中心的notify方法

事件调度中心：添加订阅者的方法，通知消息的方法 -- 内部执行订阅者的update方法

订阅者：获取消息的update方法

```js
    // 发布订阅模式

    // 发布者
    class Pub {
        constructor() {
            this.deps = [];
        }

        addDep(dep) {
            this.deps.push(dep);
        }

        publish(dep) {
            this.deps.forEach(item => item === dep && item.notify());
        }
    }

    // 订阅者
    class Sub {
        constructor(val) {
            this.val = val;
        }

        update(callback) {
            callback(this.val);
        }
    }

    // 调度中心
    class Dep {
        // 核心是这个callback函数
        constructor(callback) {
            this.subs = [];
            this.callback = callback;
        }

        // 添加一个订阅者
        addSub(sub) {
            this.subs.push(sub);
        }

        // 调度中心负责来通知
        notify() {
            this.subs.forEach(item => item.update(this.callback));
        }
    }

    // 实例化一个发布者
    let pub = new Pub()

    // 实例化一个调度中心，传入一个用于处理数据的函数-callback
    const dep1 = new Dep((data) => {
        console.log('我是调度中心，我先把消息处理一下，然后发给 ===>  ', data);
    })

    // 实例化订阅者
    let sub1 = new Sub('订阅者1');
    let sub2 = new Sub('订阅者2');

    // 发布者绑定调度中心
    pub.addDep(dep1);

    // 调度中心添加订阅者
    dep1.addSub(sub1);
    dep1.addSub(sub2);

    // 发布者把消息推给调度中心
    pub.publish(dep1);
```

## Vue nextTick的原理
nextTick中的回调是在下次DOM更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新之后的DOM。主要思路就是采用微任务优先的方式调用异步方法去执行去执行nextTick包装的方法。

[nextTick原理详解](https://juejin.cn/post/6939704519668432910#heading-4)

先将回调存到一个数组中

定义异步方法（考虑兼容性的问题，做判断，一层层的降级：promise -> MutationObserver -> setImmediate() -> setTimerout()）

```js
let callbacks = [];
let pending = false;
function flushCallbacks() {
    // 把标志还原为false;
    pending = false;

    // 依次执行回调
    for (let i = 0 ; i < callbacks.length; i++) {
        callbacks[i]();
    }
}

// 定义异步方法，采用优雅降级
let timerFunc;

if (typeof Promise !== 'undefined') {
    // 如果支持Promise
    const p = Promise.resolve();

    timerFunc = () => {
        // promise 放入微任务异步队列
        p.then(flushCallbacks);
    }
} else if (typeof MutationObserver !== 'undefined') {
    // MutationObserver 主要是 监听dom变化，也是一个异步方法。

    // 在不支持promise的情况下

    let counter = 1;
    const observer = new MutationObserver(flushCallbacks);
    const textNode = document.createTextNode(String(counter));

    observer.observe(textNode, {
        characterData: true
    })

    timerFunc = () => {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
    }
} else if (typeof setImmediate !== 'undefined') {
    // 如果前面都不支持，判断setImmediate
    timerFunc = () => {
        setImmediate(flushCallbacks);
    };
} else {
    // 最后降级采用setTimeout
    timerFunc = () => {
        setTimeout(flushCallbacks, 0);
    }
}

// 对外导出nextTick方法

export function nextTick(cb) {
    // 除了渲染watcher，还有用户自己手动调用的nextTick一起被收集数组中
    callbacks.push(cb);

    if (!pending) {
        // 如果多次调用nextTick，只会执行一次异步，等异步队列清空之后，再把标志变为false
        pending = true;
        timerFunc();
    }
}
```

## Vue diff原理

[diff算法讲解](https://juejin.cn/post/6953433215218483236)

同级比较

- tag标签不一致，直接新节点替换旧节点
- tag标签一致
    - 先进行属性替换
    - 对比子元素
        - 新老节点都有子元素，采取双指针方式进行比对，sameVNode判断tag和key完全相同为同一个节点，进行节点复用。
            - 头和头相等比较；尾和尾相等比较；头和尾相等互相比较
                - sameVnode的时候，传入两个新老子节点的patch(oldChild, newChild)
            - 乱序情况下，上面的都不符合：先遍历旧子节点数组形成key值映射到map对象，然后根据新子节点数组循环，按照key值和位置关系移动以及新增节点，最后删除多余的旧子节点，如果移动旧节点，同样需要patch(oldChild, newChild)
- 无tag标签，文本节点直接比较内容是否一致

## 路由原理history和hash两种路由方式的特点

### hash
- location.hash的值其实就是URL中#后面的东西，它的特点在于：hash虽然出现在URL中，但不会被包含在HTTP请求中，对后端没有影响，因此改变hash不会重新加载新页面。
- 可以为hash的改变添加监听事件。
```
window.addEventListener('hashchange', funcRef, false);
```
- 每一次改变hash（window.location.hash）都会在浏览器的访问历史中增加一个记录，根据以上特点，就可以实现前端路由“更新视图但不重新请求页面”的功能。
### history
- 利用了HTML5 History API中新增的pushState()和replaceState()方法
- 这两个方法应用于浏览器的历史记录栈。在当前已有的back、forward、go这三个方法的基础上，它们提供了对历史记录进行的功能。
    - 当调用它们修改浏览器历史记录栈之后，虽然 当前的URL改变了，但是浏览器不会刷新页面，这就为单页面应用“更新视图 但不重新请求页面”提供了基础
- 刷新页面会出现404，需要后端配合配配置，将404的页面定向到index.html

## 手写bind
见 -- 手写代码 -- 13.bind.html --> 简单版本 + 较为完善的版本

bind的实现要复杂一点，因为要考虑的情况比较多，还要涉及到参数的合并（类似函数柯里化）

- 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用call等方式调用的情况
- 保存当前函数的引用，获取其传入的参数值
- 创建一个函数返回
- 函数内部使用apply来绑定函数调用。需要判断函数作为构造函数的情况，这个时候需要传入当前的this给apply使用，其余情况都传入指定的上下文对象

## 手写实现一个寄生组合式继承

### 原型链的继承
- 原理：让子类的原型对象指向父类的实例，当子类的实例找不到对应的属性和方法时，会延续着原型对象（也就是它的父类）往上找
- 缺点：
    - 多个实例指向同一个原型，其中一个有修改，会影响到另一个
    - 没有实现super功能，对父类进行传参
```
function Parent(name) {
    this.name = name;
}

function Child() {

}

// 子类的原型对象指父类的实例
Child.prototype = new Parent();
Child.prototype.constructor = Child

```

### 构造函数继承
- 原理：在子类的构造函数中，去执行父类的构造函数，并且为其绑定子类的this
- 缺点：不能继承在父类原型上的方法和属性
```
function Parent(name) {
    this.name = name;
}

// 子类的构造函数 --- 调用父类的构造函数，并且为其绑定this
function Child(name) {
    Parent.call(this, name);
}
```

### 寄生组合式继承

#### 组合式继承
- 原理：构造函数式继承 + 原型链式继承
- 缺点：每生成一个子类的实例，就会执行一次new Parent 和 Parent.call
```
function Parent(name) {
    this.name = name;
}

function Child(name) {
    Parent.call(this, name);
}

Child.prototype = new Parent();
```

#### 寄生组合式继承
**解决了组合式继承中，构造函数可能被多次执行的问题**
```js
function Parent(name) {
    this.name = name;
}

function Child(name) {
    Parent.call(this, name);
}

// 在组合式继承中，使用的new Parent，构造函数就可能被多次执行
Child.prototype = Parent.prototype;

// 浅拷贝解决   ---   子类的prototype指向了父类的prototype，子类原型的改动可能会影响到父类原型
Child.prototype = Object.assign(Parent.prototype);
```

## 手写new
- 生成一个新的对象实例
- 取到第一个参数，即构造函数
- 将新生成的实例对象的原型指向构造函数
- 改变this的指向
- 返回实例对象（若构造函数有返回值，则返回构造函数的返回值，若构造函数没有返回值，则返回新生成的实例对象）

```js
function myNew () {
    // 生成一个新的对象实例
    let obj = new Object();

    // 获取第一个参数
    let constructor = Array.prototype.shift.call(arguments);

    // 将新生成的实例的对象原型指向构造函数
    obj.__proto__ = constructor.prototype;


    // 改变this的指向
    constructor.call(obj, ...arguments);

    // 返回一个新的对象实例
    return obj

    // 若构造函数有返回值
    let ret = constructor.call(obj, ...arguments);

    return typeof ret === 'object' ? ret : obj;
}
```

## 手写setTimeout模拟实现setInterval
```js
function mySettimeout(fn, time = 1000) {
    let timer = null;
    let isClear = false;

    function interval() {
        // 当isClear设置为true时，停止该定时器的调用
        if (isClear) {
            isClear = false;
            clearTimeout(timer);
            return;
        }

        // 调用定时器传入的回调
        fn();

        // 递归调用
        timer = setTimeout(interval, time);
    }

    // 先执行一次
    timer = setTimeout(interval, timer);

    // 调用该函数，返回值为一个函数，返回函数中将isClear置为true
    return () => {
        isClear = true;
    }
}
```
## TypeScript 中的 interface 和 type

### interface
- 接口，是TS设计出来的用于定义对象类型的，可以对对象的形状进行描述
```
interface Person {
    name: string,
    age: number
}

const person: Person = {
    name: '李四',
    age: 20
}
```
### type
- 类型别名，类型别名只是给类型起一个新的名字，**它并不是一个类型，只是一个别名而已**

**类型别名会让TS看起来更加的简洁、清晰**

```
type Name = string; // 给string这个类型起了一个别名  Name
type NameResolver = () => string;  // 给 一个函数起了一个别名   NameResolver
type NameOrResolver = Name | NameResolver;

// getName这个方法的参数
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    } else {
        return n();
    }
}
```

```
type Person = {
    name: string,
    age: number
}

const person: Person = {
    name: '222',
    age: 30
}
```

### 相同点
- 都可以定义一个对象或者函数
    ```
    // 定于函数的写法
    type addType = (num1: number, num2: number) => number;

    interface addType {
        (num1: number, num2: number): number
    }

    const add:addType = (num1, num2) => {
        return num 1 + num2;
    }
    ```
- 都允许继承（extends）
    **interface使用extends实现继承；type使用交叉类型实现继承**
    - interface继承interface
        ```
        interface Person {
            name: string
        }

        interface Student extends Person {
            grade: number
        }
        ```
    - type继承type
        ```
        type Person {
            name: string
        }

        type Student = Person & { grade: number } // 用交叉类型
        ```
    - type继承interface
        ```
        interface Person {
            name: string
        }

        type Student = Person & { grade: nnumber } // 用交叉类型
        ```
    - interface继承type
        ```
        type Person {
            name: string
        }

        interface Student extend Person {
            grade: number
        }
        ```

### 不同点
- 类型别名会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其他任何你需要手写的类型
    - 声明基本类型
        ```
        type Name = string
        ```
    - 声明联合类型
        ```
        type arrItem = number | string
        const arr:arrItem[] = [1, '2', 3]
        ```
    - 声明交叉类型
        ```
        type Student = Person & { grade: number }
        ```
    - 声明元组
        ```
        type Teacher = Person & { major: string }

        type StudentAndTeacherList = [Student, Teacher]; // 元组类型
        const list:StudentAndTeacherList = [
            { name: 'lin', grade: 100 }, 
            { name: 'liu', major: 'Chinese' }
        ]
        ```
- interface ---  合并重复声明
    - 当有重复声明的interface，会自动合并，类型别名不会自动合并

## SEO
搜索引擎优化，一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的排名的方式。

- 优化:
    - title description  keyword
    - 利用好HTML语义化
    - 重要的东西放前面
    - 少用iframe

## doctype
标准模式的渲染方式和JS的解析方式都是按照浏览器支持的最高标准进行的。

兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。

DOCTYPE的存在，就是为了声明，该页面的使用标准模式，不声明，可能一些旧的网站会出现兼容模式。

## 手写发布订阅模式
- 一个存储订阅信息的对象  --- 构造函数中初始化
- 一个on事件 --- 订阅
- 一个off事件 --- 删除订阅
- 一个once事件 --- 只触发一次的处理
- 一个emit事件 --- 触发回调事件的

```
class EventEmitter {
    construct() {
        this.events = {}
    }

    on () {

    }

    off() {

    }

    once(type, callback) {
        function fn () {
            callback();
            this.off(type, fn);
        }

        // 执行新写的fn函数，在fn函数内部执行callback，之后将中间函数fn删除
        this.on(type, fn);
    }

    emit() {

    }
}
```

## Vue中的this指向
### 生命周期钩子的this
生命周期钩子函数的this上下文指向调用它的Vue的实例
    
所有的生命周期钩子自动绑定this上下文到实例中，因此可以访问数据，对property和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。箭头函数绑定了父上下文，因此this与你期待的Vue实例不同

### Vue中回调函数中的this
```js
methods: {
    logThis() {
        consoel.log(this, 'methods中的this');
    },
    onclick() {
        console.log(this, 'vue中的this');
        setTimeout(this.logThis);

        setTimeout(function () {
            console.log(this, '回调函数中的bind前的this');
        })

        setTimeout(function () {
            console.log(this, '回调函数中bind后的this');
        }.bind(this));
    }
}
```

- 若回调函数为**匿名函数**，非严格模式下，指向window，严格模式下为undefined
- 若回调函数为自定义方法，则this指向Vue实例
- 若回调函数为箭头函数，则this指向Vue实例（父级的this）

### Vue中addEventListener中的this
通常，事件监听函数中的this都指向绑定事件的那个元素，但是在Vue中，监听函数中的this也指向Vue实例。

**除了回调函数中的this，其他地方的this均指向Vue实例（回调函数为箭头函数或者自定义方法，）**

## Vue中this读取数据 -- 避免滥用

### this读取data中数据的过程
- data中数据，会被添加getter和setter，将其转换成响应式的。
- this读取数据时，会触发getter函数
- 存在Dep.target时，使用this读取data中的数据，会去收集依赖。如果滥用this读取data中的数据，会多次重复的收集依赖，从而产生性能问题

## 手写防抖函数
- 防抖：持续触发某一个事件，只有在某一段时间后不触发了才会执行事件处理函数
- 节流：持续触发某一个事件，一段时间内只会执行一次事件处理函数

## MVVM
- VM做了两件事达到了数据的双向绑定
    - 【模型】转换为【视图】，即将后端传递的数据转化成页面上看到的数据。 --- 数据绑定
    - 【视图】转换为【模型】，即将页面上所看到的转换成后端的数据。 --- dom事件监听
- 严格的MVVM要求View不能和Model直接通信，而Vue提供了$ref这个属性，让Model可以直接操作View，违反了这一规定，所以说Vue没有完全遵循MVVM。

## 观察者模式和发布订阅模式
观察者模式是指，一个对象（subject）维持一系列依赖于它的对象（observe），当有关状态发生变更时Subject对象则通知一系列的Obsever对象进行更新

在观察者模式中，Subject对象拥有添加 、删除和通知一系列Observe的方法等等，而Observe对象拥有更新的方法等等。一对多

发布订阅模式中，可以基于不同的主题去执行不同的自定义事件，发布订阅模式要比观察者模式更加的灵活多变。多对多

## 0.5PX的线
- 直接设置0.5px，不同的浏览器会有不同的表现
- 缩放：设置1px，scale 0.5
    ```
    .line {
        height: 1px;
        transform: scaleY(0.5)
    }
    ```


## Vue生命周期
- updated：避免在此期间更改数据，因为这可能导致无限循环的更新，该钩子在服务端渲染期间不被调用。
- destoryed：该钩子在服务器端渲染期间不被调用。
- activated: 组件被激活时调用(keep-alive)
- deactivated：组件被销毁时调用(keep-alive)
- created及其之后，就可以发起异步请求了。推荐在created中发起。
    - created中发起异步请求，可以更快速的获取数据，减少页面loading的时间
    - ssr不支持beforeMount、mounted钩子函数，所以放在created中有助于一致性。

## Vue的单向数据流
数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件以外的改变父级组件的状态，从而导致数据流向难以理解

子组件要修改父组件的值，可以通过$eimt的方式通知父组件，让父组件去修改。

## computed和watch

### computed
计算属性，依赖其他属性计算值，并且computed的值是有缓存的，只有当计算值变化才会返回内容，可以设置getter和setter

一般会用在模板渲染中，某个值是依赖了其他的响应式对象甚至计算属性而来

如果计算属性依赖的值不发生变化，页面更新的时候不会重新计算，计算结果会被缓存，可以用来优化性能

### watch
监听属性，监听到值的变化就会执行回调，在回调中处理一些逻辑操作

适用于观测某个值的变化去完成一段复杂的业务逻辑

## Vue如何检测数组的变化
考虑到性能原因，没有用defineProperty对数组的每一项进行拦截，而是选择对7中数组的方法进行了重写**push、shift、pop、splice、unshift、sort、reverse**

## Vue3的新变化
响应式原理的改变

组件声明方式的修改，Vue3使用composition API，setup是新增的一个选项，是组件内使用composition API的入口

[Vue3新特性以及使用校验的总结](https://juejin.cn/post/6940454764421316644)

## Vue2和Vue3的响应式原理的区别
vue3使用proxy替代Object.defineProperty。Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。

## Vue的父子组件生命周期钩子函数的执行顺序
- 子组件的更新过程
    父 b-u   子 b-u  子u  父u
- 销毁过程
    父 b-d  子b-d  子d  父d

## Vue声明响应式的方式
部分场景下，使用解构之后，数据就不能再保持响应式，使用toRef可以继续保持响应式

- reactive：只能处理引用类型
- ref：可以处理js基础类型和引用类型
    ```
    setup() {
        // ref实现对对象的双向绑定
        const obj = ref({ count: 1, name: '张三' })
        setTimeout(() => {
            obj.value.count = obj.value.count + 1;
            obj.value.name = '李四';
        })

        return {
            obj
        }
    }
    ```
- toRefs：用于将一个reactive对象转换为属性全部为ref对象的普通对象
    ```
    const user = reactive({ nickname: 'xiaofan', age: 26, gender: '女' });

    return {
        ...toRefs(user)
    }

    // ...toRefs：首先是解构，然后是toRefs转换成ref对象
    ```

## Vue3的监听
- watch：有三个参数
    - source：用于指定要侦听的响应式变量，可以支持string object function array
    - callback：执行的回调函数
    - options：支持deep、immediate、flush选项
    ```
    watch(() => state.age, (newValue, preValue) => {})
    ```
- watch：默认情况下是惰性的，也就是说仅在侦听的源数据变更时才会执行回调。当使用immediate:true时，侦听的回调就会立即执行
- watch：会在组件被销毁时自动停止，如果在组件销毁之前，我们想要停止掉某个监听，可以调用`watch()`函数的返回值
    ```
    const stopWatchRoom = watch(() => state.room, (newType, oldType) => {
        console.log("新值:", newType, "老值:", oldType);
    }, {deep:true});

    setTimeout(()=>{
        // 停止监听
        stopWatchRoom()
    }, 3000)

    ```


- watchEffect：会自动收集依赖，只要指定一个回调函数。在组件初始化时，会执行一次来收集依赖，然后当收集到的依赖中数据发生变化时，就会再次执行回调函数。
    - watchEffect不需要手动传入依赖
    - watchEffect会先执行一次用来自动收集依赖
    - watchEffect无法获取到变化前的值，只能获取变化后的值
    ```
    watchEffect(() => {
        console.log(state.age);
        console.log(state.name);
    })
    ```

## Vue3的Suspense
在前后端交互获取数据时，是一个异步的过程，一般我们都会一共一个加载中的动画，当数据返回时配合-if来控制数据的显示。

Vue3提供的新的内置组件`Suspense`，它提供两个`template`slot，刚开始会渲染一个fallback状态下的内容，直到到达某个条件后才会渲染default状态的正式内容。

```
<Suspense>
    <temlate #default>
        <async-component />
    </template>
    <temlate #fallback>
        <div>
            Loading...
        </div>
    </template>
</Suspense>
```

**Suspense只是一个带插槽的组件，只是它的插槽 指定了`default`和`fallback`两种状态**

## Vue3的tree-shaking
Vue3在考虑到`tree-shaking`基础上，重构了全局和内部的API，表现结果就是现在的全局API需要通过`ESModule`的引用方式进行具名引用

```
// vue2中的写法
import Vue from 'vue';

Vue.nextTick(() => {})

// $nextTick() 只是  Vue.nextTick的一个简易包装
```

```
// Vue3中的写法
import { nextTick } from 'vue';

nextTick(() => {})
```

### 受影响的API
以下这些API只能通过具名导入的方式来使用
- Vue.nextTick
- Vue.observer (用Vue.reactive替代)
- Vue.version
- Vue.compile（仅限完整版本的时候可用）
- Vue.set （仅在2.X兼容的版本中可用）
- Vue.delete (与上同)

## Vue3中v-model的升级 

### Vue2中的v-model
在Vue2中，使用v-model其实就相当于传递了value属性，并触发了input事件。
```
<search-input v-model="searchValue"></search-input>
<search-input :value="searchValue" @input="searchValue = $event"></search-input>
```

自定义实现v-model
```
export default {
    model: {
        prop: 'search',
        event: 'change'
    }
}
```

在子组件中触发事件
```
this.$emit('update:visible', false);
```

### Vue3中的v-model
在Vue3中，使用v-mode其实就相当于传递了modelValue属性，同时触发一个update:modelValue事件
```
<modal v-model="isVisible"></modal>

<modal :modelValue="isVisible" @update:modelValue="isVisible = $event">
```
如果要绑定属性名，只需要给v-model传递一个参数就行，同时可以绑定多个v-model
```
<modal v-model:visible="isVisible" v-model:content="content"></modal>

<modal
    :visible="isVisible"
    :content="content"
    @update:visible="isVisible = $event"
    @update:content="content = $event"
></modal>
```

## JS数组和树的处理

### 递归的方式实现数组转树
在获取children的时候调用递归的方法来处理
```
function addToTree(list, pId) {
    let flag = list.filter(item => item.pId === pId);

    return flag.length === 0 ? [] : flag.map(item => {
        let obj = { id: item.id, pId: item.pId, children: addToTree(list, item.id) };
        return obj.children.length === 0 ? { id: obj.id, pId: obj.pId } : obj;
    })
}


let newArr = addToTree(arr, null);

console.log(newArr);
```
### 双重for循环的实现数组转树
```
function listToTree(arr) {
    arr.foreach(element => {
        let parentId = element.pId;
        if (parentId) {
            arr.foreach(ele => {
                if (parentId === ele.id) {
                    // 当前内部循环到的这个元素是某个元素的父级元素
                    if (!ele.children) {
                        ele.children = []
                    }

                    ele.children.push(element);
                }
            })
        }
    })

    console.log(arr);

    arr = arr.filter(item => item.pId === null);
    console.log(arr);

    return arr;
}
```

### 递归-树转数组
递归的是children

```
function fn(obj, res = []) {
    // 先添加当前元素
    res.push(obj);

    if (obj.children && obj.children.length) {
        for (const item of obj.children) {
            fn(item, res);
        }
    }
}
```
### 循环-树转数组
借鉴了“栈”的数据结构特点，先入栈，再出栈
```
function treeToArray(obj) {
    let stack = [];
    let res = [];

    stack.push(obj);

    while(stack.length) {
        const item = stack[0];
        res.push(obj);
        stack.shift();

        if (item.children && item.children.length) {
            stack.push(...obj.children);
        }
    }

    return res;
}
```

## JS引用类型和基本类型的区别
### 存储位置的不同
- 基本类型
    - 存储在栈内存，存储的就是变量的实际内容
- 引用类型
    - 栈内存中存储的是指针，指向堆内存，堆内存中存储的是真实的内容

### 赋值操作
- 基本类型
    - 基本类型的变量，赋值操作，就是把值赋给新的变量
- 引用类型
    - 引用类型的赋值，赋的是指针的值，新旧变量指向的还是同一块内存地址
## Vue的provide和inject
这对选项需要一起使用，以允许一个祖先组件向其所有的子孙后代注入一个依赖，不论组件层次有多深，在其上下游关系成立的时间里面始终生效。

provide可以在祖先组件中指定我们想要**提供**给后代组件的数据或方法。而在任何后代组件中，我们都可以使用inject来接收provide**提供**的数据或者方法。

**`provide`和`inject`绑定并不是可响应式的。这是刻意为之，然而，如果你传入 了一个可监听的对象，那么其对象的属性还是可响应的**

也就是说，vue本身不会对provide中的变量进行响应式处理。所以，要想inject接收的变量是响应式的，provide本身提供的变量就需要是响应式的。

### provide/inject的使用
栗子1：

```
// 父组件
provide: {
    foo: 'bar'
}
// 子组件
inject: ['foo'],
created () {
    console.log(this.foo); // bar
}

```

```
provide() {
    return {
        text: 'bar' // 这是一个非响应式的变量
    }
}

inject: ['text']

created() {
    this.text = 'newText';  // 因为不是响应式的数据，在模板中，依然会显示 bar
}
```

## provide/inject更推荐用于组件的开发
例如：element-ui中的button的size是会受到外层form-item或者form组件的影响的，这里就需要使用provide和inject来传递数据，使用props传递属性的方式太过繁琐且可能不太可行。因为button组件和form组件之间的层级关系是不确定。

## 数组循环的方法

### map
- 数组方法
- 不改变原数组但是会返回新数组
- 可以使用break中断循环，可以使用return返回到外层函数
### forEach
- 数组方法
- 没有返回值
- 遍历的时候不用关心集合下标的问题，效率和for循环相同
- 不能使用break中断循环，不能使用return返回到外层函数。return 可以跳过循环中的一个迭代，跳过之后会执行下一个迭代
- forEach对于空数组是不会执行回调函数的
### for in **大部分用于对象**
- 用于循环遍历数组或对象属性
- 可以遍历数组的键名，遍历对象简洁方便
- 循环的是`key`
- 会遍历到原型链上属性


### for of **不能遍历对象**
- 可遍历map、object、array、set、string等，用来遍历数组，比如组中的值
- 避免了`for...in`的所有缺点。可以使用`break`，`continue`，`return`，不仅支持数组的遍历，还可以遍历类似数组的对象。
- 替代`for...in`和`forEach`
- 循环出的是`value`

## 虚拟DOM是什么，有什么优缺点？
虚拟DOM本质就是用一个原生的JS对象去描述一个DOM节点 ，是对真实DOM的一层抽象。

前端性能优化的一个秘诀就是尽可能少的操作DOM，不仅仅是DOM相对较慢，更因为频繁的操作DOM会造成浏览器的回流或重绘。其次，现代前端框架的一个基本要求就是无需手动操作DOM，一方面是因为手动操作DOM无法保证程序性能优化，多人协作项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以提升开发效率。最后，虚拟DOM最初的目的就是更好的跨平台，虚拟DOM本质就是一个JavaScript对象。

虚拟DOM比较轻，真实DOM会比较重，虚拟DOM不需要真实DOM上那么多的属性

### 优点
- 保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现必须是普适的，所以它的性能不是最优的；但是比起粗暴的DOM操作，性能要好很多，因此框架的 虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供不错的性能，即保证性能的下限。
- 无需手动操作DOM
- 跨平台：虚拟DOM本质上JavaScript对象，而DOM与平台是强相关，相比之下虚拟DOM可以进行更方便的跨平台操作，例如服务器渲染

### 缺点
- 无法进行极致的优化
- 首次渲染大量的DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢

## V-model的原理
- v-model是一个语法糖
- v-model在内部为不同的元素使用不同的property并抛出不同的事件
- v-model可以使用model这个选项来自定义实现
    ```
    model: {
        prop: name,
        event: 'change'
    }
    ```
- vue2中的v-model，默认是value+input
- vue3中的v-model，默认是modelValue+update:modelValue

## v-for为什么要加key
如果不使用key，Vue会使用一种最大限度减少动态元素，并且尽可能的尝试就地修改/复用相同类型元素的算法。key是vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确快速

- 更准确：因为key就不是就地复用了，在sameNode函数a.key === b.key对比中可以避免就地复用的情况。
- 利用key的唯一性生成map对象来获取节点，比遍历的方式更快

Vue源码中，会 判断两个VNode的标签和key是否相同，如果相同，就可以认为是同一个节点就地复用

Vue源码中，会根据key来创建老的儿子的index映射表，类似{ 'a': 0, 'b': 1 }，代表key为'a'的节点在第一个位置，key为'b'的节点在第二个位置

## Vue事件绑定原理
原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。如果要在组件上使用原生事件，需要加`.native`修饰符，这样就相当于在父组件中把子组件当做普通的HTML标签然后加上原生事件。

`$on`、`$emit`是基于发布订阅模式的，维护一个事件中心，on的时候将事件名称存在事件中心，称之为订阅者，然后emit将对应的事件进行发布，执行事件中心里对应的监听器。

## Vue-router路由钩子函数是什么？执行顺序是什么？

### 路由钩子的类型
- 全局守卫
    - beforeEach
    - afterEach
    - beforeResolve
- 路由守卫
    - beforeEnter：它会紧跟在`beforeEach`之后触发
- 组件守卫
    - beforeRouteEneter：在`beforeEach`，`beforeEnter`之后执行，此时组件还没有解析完
    - beforeRouteUpdate
    - beforeRouteLeave

### 完整的导航解析流程
- 导航被触发
- 在失活的组件里面调用`beforeRouteLeave`守卫
- 调用全局的`beforeEach`守卫
- 在重用的组件里面调用`beforeRouteUpdate`守卫
- 在路由配置里调用`beforeEnter`守卫
- 解析异步路由组件
- 在被激活的组件里调用`beforeRouteEnter`守卫
- 调用全局的`beforeResolve`守卫
- 导航被确认
- 调用全局的`afterEach`钩子
- 触发DOM更新
- 调用`beforeRouteEnter`守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入


点击一个按钮触发页面跳转的时候，首先当前的页面会失活，调用`beforeRouteLeave`钩子

要切换到一个新的页面了，就会调用全局的钩子`beforeEach`

如果下一个要跳转到的页面，是可以重用的，那就调用`beforeRouteUpdate`更新的钩子

紧接着调用路由独享守卫`beforeEnter`，这个时候路由还没有解析完成

页面被激活了，那就会调用页面的`beforeRouteEnter`组件，这个时候还没有解析完成，还不能访问组件的实例，但是可以使用回调函数

解析路由，全局的`beforeResolve`钩子被调用

导航被确认之后，`afterEach`钩子调用

创建组件实例完成，之前`beforeRouteEnter`中的回调函数执行，组件实例会作为回调函数的参数传入

## Vue-router的动态路由是什么？有什么问题？
我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件。例如，我们的user组件，对于所有ID各不相同的用户，都要使用这个组件来渲染。那么，我们可以在vue-router的路径中使用**动态的路径参数**来达到这个效果。

**动态路径参数，以冒号开头**

```
routes: [
    { path: '/user/:id', component: User }
]
```

### vue-router中组件复用导致的路由参数失效怎么办？
- 通过watch监听路由参数再发请求
    ```
    watch: {
        '$route': function () {
            this.getData(this.$route.params.xxx);
        }
    }
    ```
- 用`:key`来阻止复用
    ```
    <router-view :key="$route.fullPath"></router-view>
    ```
## Vuex为什么要分模块，并且加命名空间
由于使用单一的状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相当臃肿。为了解决以上问题，Vuex允许我们将store分隔成模块(module)。每个模块拥有自己的state、getters
actions、mutations、甚至是嵌套子模块。

默认情况下，模块内部的action、mutation、getter是注册在全局命名空间的，这样使得多个模块能够对同一个mutation、action做出响应。如果希望你的模块具有更高的封装度和复用性，可以通过添加`namespaced: true`的方式使其成为带命名空间的模块。当模块被注册之后，它的所有getter、action、mutation都会自动根据模块注册的路径调整命名。

## vuex的进阶使用
map系列：
### mapState
```js
import { mapState } from 'vuex';

computed: {
    // 没有使用命名空间
    ...mapState(['data1', 'data2', 'data3'])

    // 使用了命名空间
    ...mapState('namespace1/dataspace', [
        'data1',
        'data2'
    ])
},
created() {
    this.data1;
    this.data2;
    this.data3;
}
```
### mapGetters
```js
computed: {
    ...mapGetters(['data1', 'data2']);

    ...mapGetters('namespace1/dataspace', [
        'data1',
        'data2'
    ])
}
```
### mapMutations
```js
methods: {
    ...mapMutations(['methods1', 'methods2']);

    ...mapMutations('namespace/space1', [
        'methods1'
    ])
}
```
### mapActions

## Vue中使用了哪些设计模式
- 工厂模式：传入参数即可创建实例。虚拟DOM根据参数的不同返回基础标签的Vnode和组件Vnode
- 单例模式：整个程序有且只有一个实例
- 发布订阅模式（Vue的事件机制）
- 观察者模式（响应式数据原理）
- 装饰模式（@装饰器的用法）
- 策略模式：策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现方案，比如选项的合并策略

## Vue.mixin的使用场景和原理
使用vue的mixin功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时，会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名的选项时，这些选项将以恰当的方式进行“合并”

## nextTick使用场景和原理
nextTick中的回调是在下次DOM更新循环结束之后执行的延迟回调。

主要思路就是采用微任务优先的方式调用异步方法去执行nextTick包装的方法。

## keep-alive的使用场景和原理
keep-alive是vue内置的一个组件，可以实现组件的缓存，当组件切换时，不会对当前组件进行卸载

常用的两个属性：include / exclude，允许组件有条件的进行缓存。
- include：要缓存的组件
- exclude：要排除的组件
- max：最大缓存数

两个生命周期：activated / deactivated，用来得知当前组件是否处于活跃状态

keep-alive中还运用了`LRU`（最近最少使用算法），选择最近最久未使用的组件予以淘汰
- LRU算法是什么？
    - 将新数据从尾部插入到`this.keys`中
    - 每当缓存命中（即缓存数据被访问），则将数据移到`this.keys`的尾部
    - 当`this.keys`满的时候，将头部的数据丢弃
- `LUR的核心思想是`：如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存组件key重新插入到this.keys的尾部，这样一来，this.keys中越往头部即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来访问几率最低的数据，即this.keys中第一个缓存的组件。

## Vue.set方法原理
以下情况下修改数据，Vue是不会触发视图更新的
- 在实例创建之后添加新的属性到实例上，（给响应式对象新增属性）
- 直接更改数组下标来修改数组的值

**Vue.set或者$set的原理如下**
因为响应式数据，我们给对象和数组本身都增加了__ob__属性，代表的是Observer实例。

当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪，然后会触发对象的__ob__的dep收集到watcher去更新，当修改数组索引时，我们调用数组本身的splice方法去更新数组。

## Vue.extend作用和原理
Vue.extend使用基础Vue构造器，创建一个子类。参数是包含组件选项的对象。

其实就是一个子类构造器，是Vue组件的核心API，实现思路就是使用原型继承的方法返回了Vue的子类，并且利用mergeOptions把传入组件的options和父类的options进行了合并。

```
export default function iniExtend(Vue) {
    // 组件的唯一标识
    let cid = 0;

    // 创建子类 继承Vue父类，便于属性扩展
    Vue.extend = function(extendOptions) {
        // 创建子类的构造函数，并且调用初始化方法
        const Sub = function VueComponent(options) {
            // 调用Vue初始化方法
            this._init(options);
        }

        Sub.cid = cid++;
        // 子类原型指向父类
        Sub.prototype = Object.create(this.prototype);
        // constructor 指向自己
        Sub.prototype.constructor = Sub;
        // 合并自己的options和父类的options
        Sub.options = mergeOptions(this.options, extendOptions);
        return Sub;
    }

}
```

**每一个组件都是一个继承自Vue的子类，能够使用Vue的原型方法**

## 自定义指令，原理是什么？
指令本质上就是装饰器，是Vue对HTML元素的扩展，给HTML元素增加自定义的功能。vue编写dom时，会找到指令对象，执行指令的相关方法。

### Vue2中的自定义指令钩子函数
自定义指令有五个生命周期（也叫钩子函数）：
- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- inserted：被绑定元素插入到父节点时调用（仅保证父节点存在，但不一定父节点已经被插入文档中）
- update：被绑定元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。
- componentUpdated：被绑定元素所在模板完成一次更新周期时调用
- unbind：只调用一次，指令与元素解绑时调用


### Vue3中自定义指令钩子函数
- created：元素创建之后，但是属性和事件还没有生效时调用
- beforeMount：仅调用一次，当指令第一次绑定元素的时候调用 `bind`
- mounted：元素被插入父元素时调用 `inserted`
- beforeUpdate：在元素自己更新之前调用
- updated：元素或者子元素更新之后调用 `componentUpdated`
- beforeUnmount：元素卸载前调用
- unmounted：当指令卸载后调用，仅调用一次 `unbind`

### 钩子函数的参数
- el：指令绑定的元素，可以用来直接操作DOM
- binding：数据对象，包含以下属性
    - instance: 当前组件的实例 --- `vue3中获取组件实例的写法`
    - value: 指令的值
    - oldValue: 指令前一个值
    - arg: 传给指令的参数，例如v-on:click中的click
    - modifiers：包含修饰符的对象。例如v-on:stop:click可以获取到一个{ stop: true }的对象
- vnode：Vue编译生成的节点
- prevVNode：Update时的上一个虚拟节点

- vue2中获取组件实例的写法：bind(el, binding, vnode) { const vm = vnode.context }
- vue3中获取组件实例的写法：bind(el, binding, vnode) { const vm = binding.instance }

### 自定义指令的原理
- 在生成ast语法树时，遇到指令会给当前元素添加directives属性
- 通过genDirectives生成指令代码
- 在path前将指令的钩子提取到cbs中，在patch过程中调用了对应的钩子
- 当执行指令对应的钩子函数时，调用对应指令定义的方法

## Vue的修饰符有哪些

### 事件修饰符
- .stop：阻止事件继续传播
- .prevent：阻止标签的默认行为
- .capture：使用事件捕获模式。即元素自身触发的事件先在此处处理，然后再交由内部元素进行处理
- .self：只当在`event.target`是当前元素自身时触发处理函数
- .once：事件将只会触发一次
- .passive：告诉浏览器你不想阻止事件的默认行为
### v-model的修饰符
- .lazy：通过这个修饰符，转变为在change事件在同步
- .number：自动将用户的输入值转换为数值类型
- .trim：自动过滤用户输入的首尾空格
### 键盘事件的修饰符
- .enter
- .tab
- .delete（捕获删除或者空格键）
- .esc
- .space
- .up
- .down
- .left
- .right
### 系统修饰符
- .ctrl
- .alt
- .shift
- .meta
### 鼠标按钮修饰符
- .left
- .right
- .niddle

## Vue模板编译原理
Vue的模板编译过程就是**将template转化为render函数**的过程，分为以下三步：
- 第一步是将 模板字符串 转换成 element ASTs -- 解析器
- 第二步是对 AST 进行进行静态标记，主要是用来做虚拟DOM的渲染优化 --- 优化器
- 第三步是 使用 element ASTs 生成render函数代码字符串

## Vue生命周期钩子是如何实现的
Vue的生命周期钩子核心实现是利用发布订阅模式先把用户传入的生命 周期钩子订阅号（内部采用数组的方式存储），然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）

## Vue函数式组件使用场景和原理

### 函数式组件和普通组件的区别
- 函数式组件需要在声明组件时指定 `functional: true`
- 不需要实例化，所以没有this，this通过render函数的第二个参数context来替代
- 没有生命周期钩子函数，不能使用计算属性、watch
- 不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件
- 因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement
- 函数式组件的props可以不用显示的声明，所以在props里面声明属性都会被自动的隐式解析为props，而普通组件所有未声明的属性，都将解析到 $attrs 里面，并自动挂载到组件根元素上面

### 函数式组件的优点
- 函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要优于普通组件
- 函数式组件结构比较简单，代码结构更加清晰

### 函数式组件的使用场景
- 一个简单地展示组件，作为容器组件使用，比如router-view就是一个函数式组件
- “高阶组件” --- 用于接收一个组件作为参数，返回一个被包装过的组件

## Vue-Router中常用的路由模式实现原理

### hash模式
- location.hash的值，实际就是URL中#后面的东西，它的特点在于：hash虽然出现在URL中，但不会被包含在HTTP请求中，对后端没有任何影响，因此改变hash的值不会重新加载页面

- 可以为hash的改变添加监听事件
    ```
    window.addEventListener('hashChange', funcRef, false);
    ```

每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，利用hash以上的特点，就可以实现前端 路由“更新视图但不重新请求页面”的功能了。

兼容性好，但是不美观

### history模式
利用了HTML5 History Interface中新增的`pushState()`和`replaceState()`方法。

这两个方法应用于浏览器的历史记录栈，在当前已有的back、forward、go的基础上，他们提供了对历史记录进行修改的功能，这两个方法有个共同的特点：
- 当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会刷新页面，这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础。

虽然美观，但是刷新会出现404，需要后端配合进行配置

## JS的深拷贝与浅拷贝
JS的深拷贝和浅拷贝，一般是针对引用类型数据的说法，对于基本类型来说，没有深拷贝、浅拷贝这一说法。

### 浅拷贝
创建新的数据，这个数据有着原始数据**属性值的一份精确的拷贝**。如果属性是基本类型，那么拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。

即：**浅拷贝是拷贝一层**，深层次引用类型则是共享内存地址。

浅拷贝的实现
```js
function shallowCopy(obj) {
    const newObj = {};
    for (let prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            newObj[prop] = obj[prop];
        }
    }

    return newObj;
}
```

常见实现浅拷贝的方法：
- object.assign
- 扩展运算符实现的赋值
- Array.proptotype.slice()、Array.prototype.concat()
- lodash的_.clone方法

### 深拷贝
深拷贝开辟一个全新的栈，两个对象的属性完全相同，但是对应不同的地址，修改一个对象的属性，不会改变到另一个属性。

常见实现深拷贝的方法：
- _.cloneDeep()
- JSON.stringfy
    - 该方法会忽略`undefined`、`symbol`和`函数`
- 手写循环递归
    ```
    function deepClone(obj, hash  = new WeakMap()) {
        if (obj === null || obj === undefined) return;
        if (obj instanceof Date) return new Date(obj);
        if (obj instanceof RegExp) return new RegExp(obj);

        // 基本类型的数据，直接返回
        if (typeof obj !== 'obj') return obj;

        // 引用类型的数据，先判断是否存在在hash中了
        if (hash.get(obj)) return hash.get(obj);

        let cloneObj = new obj.constructor();
        hash.set(obj, cloneObj);

        for (let key in obj) {
            if (obj.hashOwnProperty(key)) {
                // 递归的拷贝
                cloneObj[key] = deepClone(obj[key]. hash);
            }
        }

        return cloneObj;
    }
    ```

## async await
async用来声明一个异步方法；await用来等待异步方法执行

async函数返回一个promise对象

```
async function asyncFuc() {
    return 'TEST';
}

function f() {
    return Promise.resolve('TEST');
}
```

不管await后面跟着的是什么，await都会阻塞后面的代码（即加入微任务队列）

## 强引用、弱引用

### 强引用
如果我们将一个引用通过变量或者常量保存时，那么这个变量或者常量就是强引用。

const user = { name: '123' }

const user2 = user

### 弱引用

#### WeakSet
- WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员
- WaekSet.prototype.delete(value)：清除WeakSet实例的指定成员
- WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中
- WeakSet的成员只能是对象，而不能是其他类型的值
- WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet
- WeakSet随时都有可能被垃圾回收掉，所以不支持遍历

```
let obj = {
    name: '13'
}

let ws = new WeakSet();
ws.add(obj);
// 赋值为null，表示这个变量的内存可以被回收了
obj = null;

ws.has(obj); // false，这个变量被回收了，不存在了
```
#### WeakMap
- WeakMap只能将对象作为键名（null除外），不接受其他类型的键名
- WeakMap保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不在需要，WeakMap里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。
- WeakMap也是不可遍历的

## instanceof的原理
A instanceof B 表示：判断A是不是B的实例

实现步骤：
- 首先获取类型的原型 - B
- 然后获取对象的原型 - A
- 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为null，因为原型链最终为null

```
function myInstanceof(left, right) {

}
```

## axios 拦截器执行顺序的源码解释
Axios.prototype.request中会创建一个数组，`var chain = [dispatchRequest, undefined]`。后面添加的请求拦截器unshift到chain的左边，添加的响应拦截器push到chain的右边，所以执行顺序是：**请求拦截器 -- 发送请求的函数  -- 响应拦截器**

## CSS单位

### px
像素。一张图片最小的一个点。

### em
参考物是父元素的`font-size`，具有继承的特点，如果自身定义了font-size，按自身来计算。一个页面上的1em不是一个固定值。

### rem
CSS3新单位，`相对于根元素HTML（网页）的font-size`，不会像em那样，依赖于父元素的字体大小，而造成混乱。
### %

### vw


### vh
可以用来是实现响应式的正方形

width: 10vh;
height: 10vh;

### vm


## Generator
创建generator函数。
```js
function* func() {
    yield 1;
    yield 2;
    yield 3;
    return 4;
}
```

Generator函数可以按需一个接一个的返回多个值，它们可以与Iterator配合，从而可以轻松的创建数据流。

Generator时可迭代的  for...of 循环

## 箭头函数和普通函数的区别

箭头函数没有自己的this，箭头函数中的this来自它的父级作用域，在定义箭头函数就已经确定了this，与谁调用的它无关。普通函数，谁调用它，this就指向谁。

箭头函数继承而来的this无法改变。

call bind apply无法改变箭头函数this的指向。

箭头函数不能作为构造函数使用：
    new一个对象时：1、创建一个新的对象 2、获取传入的第一个参数，3、改变新对象的this指向，指向第一个参数，4、新对象的构造函数赋值5、返回这个新的对象

    箭头函数不存在prototype这个属性，和[construct]对象，不能作为构造函数

箭头函数没有自己的arguments，在箭头函数上访问的arguments其实是外层作用域中的值

箭头函数没有原型prototype

箭头函数不能用作Generator函数，不能使用yield关键字。

## 如何访问一个实例的原型对象

```js
function Parent(name) {
    this.name = name;
}

let p1 = new Parent('test');

p1.__proto__ // p1的原型对象
Object.getPrototypeOf()
```

## npm：patch-packages -- 打补丁

## 跨域

协议、域名、端口，任意一个不一样，都会有跨域的问题，协议或者端口不一致导致跨域，需要后端来解决，域名和域名对应的IP也会产生跨域的问题，虽然他们指的是同一个服务器，但是表现形式不一样。

跨域的限制
    无法读取非同源网页的Cookie LocalStorage IndexDB
    无法接触非同源网页的DOM
    无法向非同源地址发送AJAX请求（可以发送，但是浏览器会拒绝接受响应）

## proxy代理的原理（跨域）

### 代理：
正向代理：一台代理服务器代理了客户端，去和目标服务器进行交互，即代理客户端。
    隐藏客户端真实的IP，突破限制访问外国网站。

反向代理：一台代理服务器代替了目标服务器，去和客户端进行交互，即代理服务端。
    隐藏服务器真实IP，提供负载均衡，即指向后端的多台服务器中空闲的一台；
    我们一般在开发中解决跨域时利用反向代理的原理，例如：Vue项目中配置了proxy代理或者nginx配置了反向代理。

    优点：安全过滤 -- 不允许用户直接接触到真实的服务器，任何访问请求都要先到达反向代理服务器，经过验证、过滤等安全操作，符合条件的请求才会被转到真实服务器。

### Vue本地项目proxy反向代理
Vue项目中，通过proxy配置反向代理，使浏览器将axios发送的带有api前缀的请求发送到**前端代理服务器**，再通过`前端代理服务器发送给后端服务器`，避免了跨域无法访问的问题。

vue反向代理替换的只是原请求地址的域名，不是标识符之前的所有内容。

```js
proxy: {
    '/api': {
        target: '',
        changeOrigin: true,
        pathRewrite: {
            '^/api': 'api'
        }
    }
}
```

浏览器显示的路径：http://localhost:8080/index

通过反向代理之后真实的路径：http://172.0.0.1:8700/index

前端单独进行跨域的配置，不用依赖后端，但是前端调试时的页面路径是localhost，无法直接获取请求到的真实地址，无法进行更好的调试。


### nginx反向代理
使用反向代理的原因：
    安全、权限：使用反向代理之后，用户端将无法请求真实的服务器，而必须首先通过nginx，可以再nginx上将危险的请求或者没有权限的请求过滤掉。
    负载均衡：单个服务器不足以满足需求时，增加服务器的数量，然后将请求分发到各个服务器，即将负载分发到不同的服务器，实现负载均衡。


## Vuex -> mapGetters等等（计算属性）

## 介绍一下Vue？

https://segmentfault.com/a/1190000012692321

前端中通常需要通过JS代码来进行一些逻辑操作，最终还要把这些逻辑的结果显示在页面上，也就是需要频繁的操作DOM，MVVM（M-model数据模型，view视图，viewmodel视图模型）通过`数据双向绑定`让数据自动的双向同步。Vue也是一个这种MVVM模式的框架，不推荐开发人员手动操作DOM，但是VUE也没有完全遵循MVVM模型，我们还是可以使用$ref访问到DOM，使用VUE，我们可以不用想着怎么操作DOM，更多的去关注如果操作数据。

使用Vue的时候，先在页面上指定一个元素，即需要听过Vue展示的内容都要放到这个元素中；

new一个Vue的实例，传入`el`（el就是指定Vue实例挂载的目标，一个已经存在在页面上的DOM元素），`data`等选项。

具体的可选项包括
- el：Vue实例要挂载的目标，一个已经存在在页面上的DOM元素
- data：Vue实例的数据对象，用于给View提供数据，需要先在data中声明数据，再使用数据。this.XXX的形式可以访问到数据
    ```
    var vm = new Vue({
        el: '#app',
        data: {
            msg: 'message~~~'
        }
    })

    vm.$data访问到data中的数据
    ```
- computed
- props
- mixins
- watch
- computed
- beforeCreate
- created
- beforeMounte
- mounted
- beforeUpdate
- updated
- activated
- deactivated
- beforeDestory
- destoryed
- methods

### Vue怎么实现MVVM的？

数据绑定
- 最常用的方式：`{{}}` --- 插值表达式

双向数据绑定
- 定义：将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响：数据的改变影响到DOM，DOM的变化影响到数据
- 原理：Object.definProperty中的get和set方法，指定读取或设置对象属性值的时候，执行的操作。
- Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更，如果一个watcher被多次触发，只会被推入到队列中一次。然后在下一次事件循环tick中，Vue刷新队列并执行实际的工作。Vue在内部对异步队列使用原生的Promise.then、MutationObserver、setImmediate、setTimeout

### Vue怎么把数据渲染到页面上（M --> V）
在对应属性的set中，通过操作DOM，实现页面上的更新

### Vue的模板编译原理
如果需要在客户端编译模板（比如传入一个字符串给`template`选项，或挂载到一个元素上并以其DOM内部的HTML作为模板），就需要加上编译器

如果使用了vue-loader，就可以使用vue.runtime.min.js，将模板编译的过程交给vue-loader，如果是在浏览器中直接通过script标签引入Vue，需要使用vue.min.js，在运行的时候编译模板。

```
// 需要编译器
new Vue({
    template: `<div>{{ hi }}</div>`
})


// 不需要编译器
new Vue({
    render(h) {
        return h('div', this.hi)
    }
})
```
## webpack的原理
webpack是一个现代JavaScript应用程序的静态模块打包器。当webpack处理应用程序时，它会递归的构建一个依赖关系，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。

### webpack的module、chunk、bundle

### Module
**不同文件类型的模块**

Webpack就是用来对模块进行打包的工具，这些模块各种各样，比如：js模块、css模块、vue模块等不同文件类型的模块。这些文件都会被loader转换为有效的模块，然后被应用所使用并且加入到依赖关系图中。相对于一个完整的程序代码，模块化的好处在于，模块化将程序分散成小的功能块，这样就提供了可靠的抽象能力以及封装的边界，让设计更加连贯、目的更加明确。而不是将所有的东西都揉再一起，既难以理解也难以管理。

### chunk
**数据块**

非初始化的:
    例如在打包时，对于一些动态导入的异步代码，webpack会帮你分割出共用的代码，可以是自己写的代码模块，也可以是第三方库（node_modules模块中的），这些被分割的文件就是chunk。

初始化的：
    写在入口文件处的各种文件或者模块依赖，就是chunk，他们最终会被捆绑在一起打包成一个main.js，这个main.js可以理解为bundle，也是chunk

### bundle
**捆绑好的最终文件**
如果说chunk是各种数据片段，那么bundle就是一堆chunk组成的“集大成者”。它经历了`加载和编译的过程`，是源文件的最终版本。

chunk是webpack处理过程中的一组模块，bundle是一个或多个chunk组成的集合。

## webpack的热更新原理
热更新：`HMR (Hot Module Replacement) 简称HMR`无需完全刷新整个页面的同时，更新模块。

刷新：
- 页面刷新：不保留 页面状态，就是简单粗暴，直接window.location.reload()。
- 模块热更替：基于`WDS （webpack-dev-server）`的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前页面状态，比如复选框选中状态、输入框的输入等。

### 热更新实现的原理
`webpack-dev-server`热更新配置

webpack-dev-server启动本地服务，本地服务启动之后，再去启动`websocket`服务，通过websocket，可以建立本地服务和浏览器的双向通信，这样就可以实现当本地文件发生变化，立马告知浏览器可以热更新代码。

热更新模块替换
- 删除过期的模块，就是需要替换的模块
- 将新的模块添加到modules中
- 通过__webpack_require__执行相关模块的代码


## JS的继承

**JS中的继承**

JS中继承的本质是一种`委托机制`，对象可以将需要的属性和方法委托给原型，需要的时候就去原型上拿，这样多个对象就可以共享一个原型上的属性和方法，这个过程中是没有复制的。

js中的继承，主要还是依靠于原型链，原型处于原型链中，既可以是某个对象的原型，也可以某个原型的实例，这样就能形成原型之间的继承方式。

- 原型与实例的关系的判定：
    - instanceof：`o instanceof Foo`,  判断o的原型链上是否有Foo.prototype指向的对象。通过获取左侧对象的原型，并判断是否与右侧对象相等，可以自己实现instanceof
    - isPropertyOf：不关心构造函数，它只需要一个用来判断的对象就行。`Foo.prototype.isPrototypeOf(o)`，判断o的原型链上是否出现过Foo.prototype。

- new 关键字绑定了实例与原型的关系。并且在实例的上下文中调用构造函数。
    - 创建一个新的对象实例
    - 将新的对象实例的原型指向构造函数的原型 `o.__proto__ = Fn.prototype`
    - 改变构造函数的this指向，执行构造函数
    - 返回新创建的对象实例（如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象）

https://juejin.cn/post/6867715946941775885

https://juejin.cn/post/7004638318843412493#heading-20

https://juejin.cn/post/7064351631072526350


https://juejin.cn/post/7063970883227877390

https://juejin.cn/post/6961222829979697165#heading-18
