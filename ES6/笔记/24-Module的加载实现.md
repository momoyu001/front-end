# module 的加载实现

## 浏览器加载
script标签加载脚本，浏览器允许脚本的异步加载。script标签中加上defer或者async属性，浏览器渲染引擎遇到这个命令，就会开始下载外部脚本，但是不会等他下载和执行，而是直接继续执行后面的命令。
- defer：要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行。 - **渲染完成再执行**。如果有多个defer脚本，会按照它们在页面中出现的顺序加载。
- async：一旦脚本下载完成，渲染引擎就会中断渲染，执行这个脚本，再继续渲染。 - **下载完再执行**。如果有多个async脚本，不能保证加载的顺序。
- 浏览器加载ES6模块，也是用script标签，但是要加入`type="module"`属性。异步加载ES6模块，渲染完成了之后执行脚本，等同于给script标签加上了`defer`属性。模块中顶层this等于undefined，利用这个特性，可以检测当前代码是否在ES6模块之中。

## ES6模块与CommonJS模块的差异
- CommonJS模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用。
    - CommonJS：一旦输出一个值，模块内部的变化就影响不到这个值。
    - ES6模块时动态引用，并且不会缓存值，动态的去被加载的模块里面取值，模块里面的变量绑定其所在的模块。不同的脚本加载一个模块，得到都是同一个实例。
- CommonJS模块时运行时加载，ES6是模块时编译时加载。CommonJS加载的是一个对象（module.exports属性），该对象 只有在脚本运行完成之后才会生成。ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

## Node.js加载
- 在Node中，要求ES6模块的文件后缀名为`.mjs`
- .mjs文件总是以ES6模块加载，.cjs总是以CommonJS模块加载，.js文件的加载方式取决于package.json中type字段的值（`module`或`commonjs`）
- 目前，一个模块同时支持ES6和CommonJS两种格式的常见写法是：`package.json`文件的`main`字段指定CommonJS入口，给Node.js使用；module字段指定ES6模块入口，给打包工具使用，因为node.js不认识module字段。
- import命令加载CommonJS模块，只能是整体加载，不能只加载单一的输出项。
- CommonJS模块通过import()来加载ES6模块。

## 循环执行

指：a脚本的执行依赖b脚本，b脚本的执行又依赖a脚本。
- CommonJS模块的加载原理：一个模块就是一个脚本文件，require命令第一次加载该脚本，就会执行整个脚本，然后再内存中生成一个对象。即使再次执行require命令，也不会再次执行该模块，而是到内存中取读取，除非手动清除系统缓存。
- CommonJS的循环加载：脚本在require的时候，就会全部执行，一旦出现某个模块被‘循环加载’，就只输出已执行的部分，还未执行的部分不输出
- ES6的循环加载：
