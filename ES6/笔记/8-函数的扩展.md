# 函数的扩展

## 函数参数的默认值
- 使用参数默认值时，不能有同名参数。
- 默认参数不是传值的，而是每次都重新计算默认值表达式的值。
- 通常情况下，定义了默认值的参数，应该是函数的尾参数（最后一个或n个参数）。
- 传入`undefined`，将触发该参数等于默认值。
- 函数的`length`属性，返回函数参数中，没有指定默认值的参数个数。
    ```
    (function foo(a, b, c = 7) {}).length // 2
    (function foo(...args) {}).length   // 0
    ```
- 如果设置默认值的参数不是尾参数，那么`length`属性也不会再计入后面的参数了。
- 作用域：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成单独的作用域(context)，等到初始化结束，这个作用域就会消失。
    - 如果函数的参数是一个函数，该函数参数的作用域也遵循这个规则。
    ```
    var x = 1;
    function foo (x, y = x) {
        // x y 形成了一个单独的作用域。
        // 相当于  let x = undefined; let y = x;
        console.log(y);
    }

    foo(2)  // 输出y = 2;

    foo()   // 输出y = undefined;   // 此时再单独的作用域中没有x具体值 ,则打印undefined。

    var x = 10;
    function boo(y = x) {   // 这个单独作用域里面，x 本身没有定义，所以只想外面的全局x，没有的话，若不存在x，则会报错
        // y = x，相当于 let y = x;
        console.log(y);
    }

    boo();
    ```

## rest参数
```
function data(...args) {
    console.log(args);  // 是一个数组
}
```

- rest参数是一个数组，可以使用数组的相关api。
- rest参数必须放到参数的最后。
- 函数的`length`属性，不包括rest参数。

## 严格模式
- 从ES5开始，函数内部可以设置严格模式
```
function foo () {
    'use strict';
}
```
- ES2016规定，只要函数参数使用了默认值，解构赋值，或者扩展运算符，那么函数内部不能显示设定为严格模式，否则会报错
    - 函数内部的严格模式，同时适用于函数体和函数参数，但是，函数执行的时候，先执行了函数参数，然后再执行函数体。只有从函数体中，才能知道参数是否应该以严格模式来执行。


## name属性
- 返回该函数的函数名
```
function foo () {

}

console.log(foo.name);  // foo
```
- `Function`构造函数返回的函数实例，`name`属性的值为`anonymous`
- `bind`返回的函数，name属性会加上`bound`前缀。

## 箭头函数
- 不可以使用`yeild`命令，因此箭头函数不能作为用作`Generator`函数。
- this对象的指向是可变的，但是在箭头函数中，它是固定的。
- 箭头函数可以让`this`指向固定化，有利于封装回调函数。
- 箭头函数没有自己的`this`，导致内部的`this`就是外层代码块的`this`，正是因为它没有this，所以也不能用作构造函数。
- 箭头函数中也不存在`arguments`，`super`，`new.target`。
- 箭头函数没有自己的this，所以bind、call、apply也是无效的。
- 箭头函数使得`this`从‘动态’变成了‘静态’。
- 不适用的场景：
    - 定义对象的方法，且该方法内部有使用到this的地方。
    - 需要动态this的时候，也不应该使用箭头函数。

## 尾调用优化
- `尾调用`： 指某个函数的最后一步是调用另一个函数。
```
function foo () {
    return g(x);
}
```

- 尾调用优化：即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。只有不再用到外层函数的内部变量，内层函数的调用帧才可以取代外层函数的调用帧，否则就无法进行尾调用。

## 尾递归
- 函数调用自身，称为递归。如果尾调用自身，那就是尾递归。
- 对尾递归来说，只存在一个调用帧，永远不会发生栈溢出错误。
- 对于ES6来说，只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时）。

## 递归函数的改写
- 改写递归函数，确保最后一步只调用自身。即：把所有用到的内部变量改写成函数的参数。
- 函数柯里化：将多个参数的函数转换为单参数的形式。

## 严格模式
- ES6的尾调用优化只在`严格模式`下开启，正常模式下是无效的。
- 正常模式下，函数内部有两个变量可以跟踪函数的调用栈。
    - `func.arguemnts`: 返回调用函数的参数
    - `func.caller`: 返回调用当前函数的那个函数
    - 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁止使用这两个变量，所以尾调用模式仅正在严格模式下生效。

## 尾递归优化的实现
- 非严格模式下：实现尾递归优化
    - 蹦床函数，将递归执行转换为循环执行，减少调用栈，避免溢出。（还不是真正的尾递归优化）
    ```
    // 返回一个函数，然后执行该函数，而不是函数里面调用函数。避免了递归执行。
    function trampoline(f) {
        while (f && f instanceof Function) {
            f = f();
        }
        return f;
    }
    ```
    - 将原来的递归函数，改写成每一步返回另一个函数（bind）
    ```
    function sum (x, y) {
        if (y > 0) {
            // 使用bind：改变this指向（返回了另一个函数），bind返回的是一个函数，不是函数的调用
            return sum.bind(null, x + 1, y + 1);
        } else {
            return x;
        }
    }
    ```
    ```
    trampoline(sum(1, 10000));
    ```

## 函数参数的尾逗号
- 允许参数的最后一个参数有尾逗号。

## Function.prototype.toString()
- 修改后的toString方法，明确要求返回一模一样的原始代码。（以前会省略注释和空格）

##  catch命令的参数省略
```
try {

} catch {
    // catch后面不需要更参数也可以了
}
```